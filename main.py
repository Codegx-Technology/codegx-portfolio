#!/usr/bin/env python3
"""
CodeCrusher - A CLI tool for code generation and transformation.
"""

import argparse
import logging
import os
import sys
import json
import time
import threading
import itertools
from typing import Dict, Any, Optional, List, Callable, Union

# Try to import rich, fall back to colorama if not available
try:
    from rich.console import Console
    from rich.status import Status
    from rich.theme import Theme
    from rich import print as rich_print
    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False
    try:
        from colorama import init, Fore, Style
        init(autoreset=True)
        COLORAMA_AVAILABLE = True
    except ImportError:
        COLORAMA_AVAILABLE = False

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger("codecrusher")

# Set up rich console if available
if RICH_AVAILABLE:
    custom_theme = Theme({
        "info": "cyan",
        "success": "green",
        "warning": "yellow",
        "error": "red bold",
        "highlight": "magenta",
    })
    console = Console(theme=custom_theme)
elif not COLORAMA_AVAILABLE:
    print("Warning: Neither rich nor colorama is installed. Running without colored output.")
    print("To install rich: pip install rich")
    print("To install colorama: pip install colorama")

def print_colored(message: str, msg_type: str = "info") -> None:
    """
    Print colored messages to the terminal.

    Args:
        message: The message to print
        msg_type: The type of message (info, success, warning, error)
    """
    if RICH_AVAILABLE:
        if msg_type == "info":
            console.print(message, style="info")
        elif msg_type == "success":
            console.print(message, style="success")
        elif msg_type == "warning":
            console.print(message, style="warning")
        elif msg_type == "error":
            console.print(message, style="error")
        else:
            console.print(message)
    elif COLORAMA_AVAILABLE:
        if msg_type == "info":
            print(f"{Fore.CYAN}{message}{Style.RESET_ALL}")
        elif msg_type == "success":
            print(f"{Fore.GREEN}{message}{Style.RESET_ALL}")
        elif msg_type == "warning":
            print(f"{Fore.YELLOW}{message}{Style.RESET_ALL}")
        elif msg_type == "error":
            print(f"{Fore.RED}{Style.BRIGHT}{message}{Style.RESET_ALL}")
        else:
            print(message)
    else:
        print(message)

class Spinner:
    """A simple spinner for showing progress during long-running operations."""

    def __init__(self, message: str = "Working..."):
        self.message = message
        self.running = False
        self.spinner_thread = None
        self.spinner_chars = itertools.cycle(['-', '\\', '|', '/'])

    def __enter__(self):
        if RICH_AVAILABLE:
            self.status = console.status(self.message, spinner="dots")
            self.status.__enter__()
        else:
            self.start()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if RICH_AVAILABLE:
            self.status.__exit__(exc_type, exc_val, exc_tb)
        else:
            self.stop()

    def start(self):
        """Start the spinner."""
        if not RICH_AVAILABLE:
            self.running = True
            self.spinner_thread = threading.Thread(target=self._spin)
            self.spinner_thread.daemon = True
            self.spinner_thread.start()

    def stop(self):
        """Stop the spinner."""
        if not RICH_AVAILABLE and self.running:
            self.running = False
            if self.spinner_thread:
                self.spinner_thread.join()
            # Clear the spinner line
            sys.stdout.write("\r" + " " * (len(self.message) + 10) + "\r")
            sys.stdout.flush()

    def _spin(self):
        """Display the spinner animation."""
        while self.running:
            char = next(self.spinner_chars)
            sys.stdout.write(f"\r{char} {self.message}")
            sys.stdout.flush()
            time.sleep(0.1)

def generate_code_with_fallback(prompt: str, config: Dict[str, Any]) -> str:
    """
    Generate code using the specified AI provider with fallback.
    This is a mock implementation for demonstration purposes.

    Args:
        prompt: The prompt for code generation
        config: Configuration dictionary

    Returns:
        Generated code as a string
    """
    # Simulate a long-running operation
    time.sleep(3)

    # Mock implementation - in a real app, this would call the AI provider's API
    provider = config.get("provider", "mistral")
    model = config.get("model", "mistral-7b")

    return f"""
def sort_list(items):
    \"\"\"
    Sort a list of items in ascending order.
    Generated by {provider} using {model}.
    \"\"\"
    return sorted(items)
"""

def load_config(config_path: str) -> Dict[str, Any]:
    """
    Load configuration from a JSON file.

    Args:
        config_path: Path to the configuration file

    Returns:
        Dictionary containing configuration values

    Raises:
        FileNotFoundError: If the config file doesn't exist
        json.JSONDecodeError: If the config file is not valid JSON
    """
    try:
        if not os.path.exists(config_path):
            warning_msg = f"Config file not found: {config_path}"
            logger.warning(warning_msg)
            print_colored(warning_msg, "warning")
            return {}

        with open(config_path, 'r') as f:
            config = json.load(f)

        # Validate config values
        valid_providers = ["mistral", "openai"]
        if "provider" in config and config["provider"] not in valid_providers:
            warning_msg = f"Invalid provider in config: {config['provider']}. Must be one of {valid_providers}"
            logger.warning(warning_msg)
            print_colored(warning_msg, "warning")
            config.pop("provider")

        if "max_retries" in config and not isinstance(config["max_retries"], int):
            warning_msg = f"Invalid max_retries in config: {config['max_retries']}. Must be an integer"
            logger.warning(warning_msg)
            print_colored(warning_msg, "warning")
            config.pop("max_retries")

        if "timeout" in config and not isinstance(config["timeout"], int):
            warning_msg = f"Invalid timeout in config: {config['timeout']}. Must be an integer"
            logger.warning(warning_msg)
            print_colored(warning_msg, "warning")
            config.pop("timeout")

        if "use_cache" in config and not isinstance(config["use_cache"], bool):
            warning_msg = f"Invalid use_cache in config: {config['use_cache']}. Must be a boolean"
            logger.warning(warning_msg)
            print_colored(warning_msg, "warning")
            config.pop("use_cache")

        if "default_tags" in config and not isinstance(config["default_tags"], list):
            warning_msg = f"Invalid default_tags in config: {config['default_tags']}. Must be a list"
            logger.warning(warning_msg)
            print_colored(warning_msg, "warning")
            config.pop("default_tags")

        info_msg = f"Loaded configuration from {config_path}"
        logger.info(info_msg)
        print_colored(info_msg, "success")
        return config

    except json.JSONDecodeError as e:
        error_msg = f"Error parsing config file {config_path}: {e}"
        logger.error(error_msg)
        print_colored(error_msg, "error")
        print_colored("Config file must be valid JSON", "error")
        return {}
    except Exception as e:
        error_msg = f"Error loading config file {config_path}: {e}"
        logger.error(error_msg)
        print_colored(error_msg, "error")
        return {}

def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="CodeCrusher - A CLI tool for code generation and transformation"
    )

    # Add config file argument
    parser.add_argument(
        "--config",
        type=str,
        help="Path to configuration file (default: codecrusher.config.json)",
    )

    # Add other arguments
    parser.add_argument(
        "--provider",
        type=str,
        choices=["mistral", "openai"],
        help="AI provider to use (mistral or openai)",
    )

    parser.add_argument(
        "--model",
        type=str,
        help="Model to use (e.g., mistral-7b, gpt-4-turbo)",
    )

    parser.add_argument(
        "--max-retries",
        type=int,
        help="Maximum number of retries for API calls",
    )

    parser.add_argument(
        "--timeout",
        type=int,
        help="Timeout in seconds for API calls",
    )

    parser.add_argument(
        "--use-cache",
        action="store_true",
        help="Use cache for API calls",
    )

    parser.add_argument(
        "--no-cache",
        action="store_true",
        help="Disable cache for API calls",
    )

    parser.add_argument(
        "--prompt",
        type=str,
        help="Prompt text for code generation",
    )

    parser.add_argument(
        "--tags",
        type=str,
        nargs="+",
        help="Tags for the generated code",
    )

    return parser.parse_args()

def merge_config_with_args(args: argparse.Namespace, config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Merge configuration from file with command line arguments.
    Command line arguments take precedence over config file values.

    Args:
        args: Command line arguments
        config: Configuration from file

    Returns:
        Dictionary with merged configuration
    """
    merged = {}

    # Start with config file values
    if "provider" in config:
        merged["provider"] = config["provider"]
    if "model" in config:
        merged["model"] = config["model"]
    if "max_retries" in config:
        merged["max_retries"] = config["max_retries"]
    if "timeout" in config:
        merged["timeout"] = config["timeout"]
    if "use_cache" in config:
        merged["use_cache"] = config["use_cache"]
    if "default_prompt_text" in config:
        merged["prompt"] = config["default_prompt_text"]
    if "default_tags" in config:
        merged["tags"] = config["default_tags"]

    # Override with command line arguments if provided
    if args.provider:
        merged["provider"] = args.provider
    if args.model:
        merged["model"] = args.model
    if args.max_retries is not None:
        merged["max_retries"] = args.max_retries
    if args.timeout is not None:
        merged["timeout"] = args.timeout
    if args.use_cache:
        merged["use_cache"] = True
    if args.no_cache:
        merged["use_cache"] = False
    if args.prompt:
        merged["prompt"] = args.prompt
    if args.tags:
        merged["tags"] = args.tags

    return merged

def main():
    """Main entry point for the application."""
    args = parse_args()

    # Determine config file path
    config_path = args.config if args.config else "codecrusher.config.json"

    # Load config file if it exists
    config = load_config(config_path)

    # Merge config with command line arguments
    merged_config = merge_config_with_args(args, config)

    # Log the final configuration
    logger.info("Final configuration:")
    for key, value in merged_config.items():
        logger.info(f"  {key}: {value}")

    # Display configuration with colored output
    print_colored("CodeCrusher is ready to run with the following configuration:", "info")
    for key, value in merged_config.items():
        print_colored(f"  {key}: {value}", "info")

    # Check if we have a prompt to generate code
    if "prompt" in merged_config:
        prompt = merged_config["prompt"]
        print_colored(f"\nGenerating code for prompt: {prompt}", "info")

        # Use spinner while generating code
        with Spinner("Generating code with AI... This may take a moment"):
            try:
                generated_code = generate_code_with_fallback(prompt, merged_config)
                print_colored("\nCode generated successfully!", "success")
                print_colored("\nGenerated code:", "info")
                if RICH_AVAILABLE:
                    console.print(generated_code, style="highlight")
                else:
                    print(generated_code)
            except Exception as e:
                print_colored(f"\nError generating code: {str(e)}", "error")
    else:
        print_colored("\nNo prompt provided. Use --prompt to generate code.", "warning")

if __name__ == "__main__":
    main()
